/**
 * Copyright (c) 2020, 2021 Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */
import FederationClient from "./models/federation-client";
import SessionKeySupplier from "./models/session-key-supplier";
import SecurityTokenAdapter from "./security-token-adapter";
export default class X509FederationClientForOkeWorkloadIdentity implements FederationClient {
    private proxymuxEndpoint;
    private kubernetesServiceAccountToken;
    private kubernetesServiceAccountCert;
    private sessionKeySupplier;
    securityTokenAdapter: SecurityTokenAdapter;
    private retry;
    constructor(proxymuxEndpoint: string, kubernetesServiceAccountToken: string, kubernetesServiceAccountCert: string, sessionKeySupplier: SessionKeySupplier);
    /**
     * Gets a security token. If there is already a valid token cached, it will be returned. Else this will make a call
     * to the OKE Proxymux service to get a new token, using the provided suppliers.
     *
     * This method is thread-safe.
     * @return the security token
     * @throws OciError If there is any issue with getting a token from the OKE Proxymux server
     */
    getSecurityToken(): Promise<string>;
    /**
     * Return a claim embedded in the security token
     * @param key the name of the claim
     * @return the value of the claim or null if unable to find
     */
    getStringClaim(key: string): Promise<string | null>;
    refreshAndGetSecurityToken(): Promise<string>;
    private refreshAndGetSecurityTokenInner;
    /**
     * Gets a security token from the OKE Proxymux service
     * @return the security token, which is basically a JWT token string
     */
    private getSecurityTokenFromServer;
}
