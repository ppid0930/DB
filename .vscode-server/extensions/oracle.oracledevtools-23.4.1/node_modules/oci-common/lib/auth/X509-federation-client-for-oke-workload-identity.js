"use strict";
/**
 * Copyright (c) 2020, 2021 Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tls_1 = require("tls");
const https_1 = require("https");
const security_token_adapter_1 = __importDefault(require("./security-token-adapter"));
const auth_utils_1 = __importDefault(require("./helpers/auth-utils"));
const http_1 = require("../http");
/**
 * This class gets a security token from the OKE Proxymux service by authenticating the request with the kubernetes service account,
 * passing along a temporary public key that is bounded to the service account.
 */
const OKE_WORKLOAD_IDENTITY_GENERIC_ERROR = "Failed to get a RPST token from Proxymux. See https://docs.oracle.com/en-us/iaas/Content/ContEng/Tasks/contenggrantingworkloadaccesstoresources.htm for more info.";
class X509FederationClientForOkeWorkloadIdentity {
    constructor(proxymuxEndpoint, kubernetesServiceAccountToken, kubernetesServiceAccountCert, sessionKeySupplier) {
        this.proxymuxEndpoint = proxymuxEndpoint;
        this.kubernetesServiceAccountToken = kubernetesServiceAccountToken;
        this.kubernetesServiceAccountCert = kubernetesServiceAccountCert;
        this.sessionKeySupplier = sessionKeySupplier;
        this.retry = 0;
        this.securityTokenAdapter = new security_token_adapter_1.default("", this.sessionKeySupplier);
    }
    /**
     * Gets a security token. If there is already a valid token cached, it will be returned. Else this will make a call
     * to the OKE Proxymux service to get a new token, using the provided suppliers.
     *
     * This method is thread-safe.
     * @return the security token
     * @throws OciError If there is any issue with getting a token from the OKE Proxymux server
     */
    getSecurityToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.securityTokenAdapter.isValid()) {
                return this.securityTokenAdapter.getSecurityToken();
            }
            return yield this.refreshAndGetSecurityTokenInner(true);
        });
    }
    /**
     * Return a claim embedded in the security token
     * @param key the name of the claim
     * @return the value of the claim or null if unable to find
     */
    getStringClaim(key) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.refreshAndGetSecurityTokenInner(true);
            return this.securityTokenAdapter.getStringClaim(key);
        });
    }
    refreshAndGetSecurityToken() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.refreshAndGetSecurityTokenInner(false);
        });
    }
    refreshAndGetSecurityTokenInner(doFinalTokenValidityCheck) {
        return __awaiter(this, void 0, void 0, function* () {
            // Check again to see if the JWT is still invalid, unless we want to skip that check
            if (!doFinalTokenValidityCheck || !this.securityTokenAdapter.isValid()) {
                this.sessionKeySupplier.refreshKeys();
                this.securityTokenAdapter = yield this.getSecurityTokenFromServer();
                return this.securityTokenAdapter.getSecurityToken();
            }
            return this.securityTokenAdapter.getSecurityToken();
        });
    }
    /**
     * Gets a security token from the OKE Proxymux service
     * @return the security token, which is basically a JWT token string
     */
    getSecurityTokenFromServer() {
        return __awaiter(this, void 0, void 0, function* () {
            const keyPair = this.sessionKeySupplier.getKeyPair();
            if (!keyPair) {
                throw Error("keyPair for session was not provided");
            }
            const publicKey = keyPair.getPublic();
            if (!publicKey) {
                throw Error("Public key is not present");
            }
            try {
                // Create request body and call auth service.
                const url = this.proxymuxEndpoint;
                const requestPayload = {
                    podKey: auth_utils_1.default.sanitizeCertificateString(publicKey)
                };
                let jsonPayload = JSON.stringify(requestPayload);
                jsonPayload = jsonPayload.replace(/\\n/g, "");
                const requestObj = {
                    uri: url,
                    body: jsonPayload,
                    method: "POST",
                    headers: new Headers({
                        "Authorization": `Bearer ${this.kubernetesServiceAccountToken}`,
                        "Content-Type": "application/json"
                    })
                };
                const httpOptions = {};
                httpOptions.agent = new https_1.Agent({
                    ca: [...tls_1.rootCertificates, this.kubernetesServiceAccountCert]
                });
                const httpClient = new http_1.FetchHttpClient(null, null, httpOptions);
                // Call OKE Proxymux Service to get a base64 encoded JSON object which contains the auth token
                const response = yield httpClient.send(requestObj);
                //TODO: Implement retry here
                // retry here
                if (response.status !== 200) {
                    if (this.retry < 3) {
                        this.retry += 1;
                        return yield this.getSecurityTokenFromServer();
                    }
                    else {
                        throw Error(`Failed to call Proxymux for RPST token. Status: ${response.status}. ${OKE_WORKLOAD_IDENTITY_GENERIC_ERROR}`);
                    }
                }
                this.retry = 0;
                // The response is a base64 blob of a json object, we need to decode and parse it
                let responseBody;
                try {
                    responseBody = yield response.text();
                }
                catch (e) {
                    throw Error(`Failed to read response body from Proxymux. ${OKE_WORKLOAD_IDENTITY_GENERIC_ERROR}`);
                }
                let decodedBodyStr;
                try {
                    decodedBodyStr = Buffer.from(responseBody, "base64").toString("utf8");
                }
                catch (e) {
                    throw Error(`Invalid JSON response received from Proxymux. ${OKE_WORKLOAD_IDENTITY_GENERIC_ERROR}`);
                }
                let parsedBody;
                try {
                    parsedBody = JSON.parse(decodedBodyStr);
                }
                catch (e) {
                    throw Error(`Invalid JSON response received from Proxymux. ${OKE_WORKLOAD_IDENTITY_GENERIC_ERROR}`);
                }
                if (!parsedBody) {
                    throw Error(`Invalid (undefined) RPST token received from Proxymux. ${OKE_WORKLOAD_IDENTITY_GENERIC_ERROR}`);
                }
                if (typeof parsedBody.token !== "string") {
                    throw Error(`Invalid (string) RPST token received from Proxymux. ${OKE_WORKLOAD_IDENTITY_GENERIC_ERROR}`);
                }
                const token = parsedBody.token;
                if (!token || token.length === 0) {
                    throw Error(`Invalid (empty) RPST token received from Proxymux. ${OKE_WORKLOAD_IDENTITY_GENERIC_ERROR}`);
                }
                if (token.length < 3) {
                    throw Error(`Invalid RPST token received from Proxymux. ${OKE_WORKLOAD_IDENTITY_GENERIC_ERROR}`);
                }
                return new security_token_adapter_1.default(token.slice(3), this.sessionKeySupplier);
            }
            catch (e) {
                throw Error(`Failed to call Proxymux, error: ${e}. ${OKE_WORKLOAD_IDENTITY_GENERIC_ERROR}`);
            }
        });
    }
}
exports.default = X509FederationClientForOkeWorkloadIdentity;
//# sourceMappingURL=X509-federation-client-for-oke-workload-identity.js.map